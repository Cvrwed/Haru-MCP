package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.List;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import net.minecraft.network.INetHandler;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketKeepAlive;
import net.minecraft.network.play.client.CPacketPlayer;

@Info(name = "Ping", category = Category.Exploit)
public class Ping extends Module {

	private ModeValue pingMode = new ModeValue("Ping", "Drop", "Drop");
	private BooleanValue legitimize = new BooleanValue("Legitimize", true);
	private SliderValue ticksExisted = new SliderValue("Ticks existed", 15, 1, 15, 1);
	private List<Packet<INetHandler>> catchPackets = new ArrayList<>();

	public Ping() {
		this.registerSetting(pingMode, legitimize, ticksExisted);
	}

	@Override
	public void onEnable() {
		synchronized (catchPackets) {
			catchPackets.clear();
		}
	}

	@Override
	public void onDisable() {
		List<Packet<INetHandler>> catch_;
		synchronized (catchPackets) {
			catch_ = new ArrayList<>(catchPackets);
			catchPackets.clear();
		}

		INetHandler netHandler = mc.getNetHandler();
		for (Packet<INetHandler> packet : catch_) {
			mc.getNetHandler().sendSilent(packet);
		}
	}

	@EventLink
	public void onLiving(LivingEvent e) {
		if (pingMode.is("Drop")) {
			List<Packet<INetHandler>> catch_;
			synchronized (catchPackets) {
				catch_ = new ArrayList<>(catchPackets);
				if (mc.player.ticksExisted % ticksExisted.getInputToInt() == 0) {
					for (Packet<INetHandler> packet : catch_) {
						mc.getNetHandler().sendQueue(packet);
					}
				}
			}
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		final Packet packets = e.getPacket();

		if (e.isSend()) {
			synchronized (catchPackets) {
				if (pingMode.is("Drop")) {
					if (catchPackets.contains(packets)) {
						catchPackets.remove(packets);
					}
					catchPackets.add(packets);
					e.setCancelled(true);
					return;
				}

				// Modo de legitimización: manejar los paquetes de CPacketPlayer
				if (legitimize.isToggled()) {
					if (packets instanceof CPacketPlayer) {
						catchPackets.add(packets);
						e.setCancelled(true);
						return;
					}
				}
				// Manejar todos los paquetes que no son del servidor y no son CPacketKeepAlive
				else {
					if (!packets.getClass().getSimpleName().startsWith("S") && !(packets instanceof CPacketKeepAlive)) {
						catchPackets.add(packets);
						e.setCancelled(true);
						return;
					}
				}
			}
		}
	}

	@EventLink
	public void onWorldLoad(ChangeWorldEvent e) {
		if (e.getChangeWorld() == null) {
			catchPackets.clear();
		}
	}

	@EventLink
	public void onDisconnect(final DisconnectionEvent e) {
		if (e.isClient()) {
			catchPackets.clear();
			disable();
		}
	}
}
