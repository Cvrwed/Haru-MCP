package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.MotionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.impl.combat.AimAssist;
import cc.unknown.module.setting.impl.SliderValue;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;

@Info(name = "LagRange", category = Category.Exploit)
public class LagRange extends Module {

    private final List<Packet<?>> packets = Collections.synchronizedList(new ArrayList<>());
    private final SliderValue packetsLag = new SliderValue("Ticks delay between packets", 2, 1, 20, 1);
    private final SliderValue distanceEnemy = new SliderValue("Distance Enemy", 5, 1, 10, 1);
    private final int preActivationBlocks = 2;

    public LagRange() {
        this.registerSetting(packetsLag, distanceEnemy);
    }

    @Override
    public void onEnable() {
        reset();
        super.onEnable();
    }

    @Override
    public void onDisable() {
        if (mc.player == null) return;
        reset();
        super.onDisable();
    }

    @EventLink
    public void onPacket(PacketEvent e) {
        if (e.isSend()) {
            synchronized (packets) {
                packets.add(e.getPacket());
            }
            e.setCancelled(true);
        }
    }

    @EventLink
    public void onPost(MotionEvent e) {
        if (e.isPost()) {
            AimAssist aimAssist = (AimAssist) Haru.instance.getModuleManager().getModule(AimAssist.class);
            EntityPlayer enemy = aimAssist.getEnemy();

            if (enemy == null) {
                if (!packets.isEmpty() && mc.player.ticksExisted % packetsLag.getInputToInt() == 0) {
                    synchronized (packets) {
                        Packet<?> packet = packets.remove(0);
                        mc.getNetHandler().sendSilent(packet);
                    }
                }
            } else {
                double distanceToEnemy = mc.player.getDistanceToEntity(enemy);
                if (distanceToEnemy <= distanceEnemy.getInputToInt() + preActivationBlocks) {
                    synchronized (packets) {
                        for (Packet<?> packet : packets) {
                            mc.getNetHandler().sendSilent(packet);
                        }
                        packets.clear();
                    }
                }
            }
        }
    }

    private void reset() {
        synchronized (packets) {
            packets.clear();
        }
    }
}