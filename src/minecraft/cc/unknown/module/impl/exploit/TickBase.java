package cc.unknown.module.impl.exploit;

import cc.unknown.Haru;
import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.player.TickEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.impl.combat.AimAssist;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.CombatUtil;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketUseEntity;

@Info(name = "TickBase", category = Category.Exploit)
public class TickBase extends Module {

	private SliderValue cooldown = new SliderValue("Cooldown", 8, 1, 20, 1);
	private SliderValue range = new SliderValue("Range", 4, 4, 10, 0.05);
	private SliderValue freeze = new SliderValue("Freeze Time", 10, 1, 20, 1);
	private SliderValue timer = new SliderValue("Timer", 0.5, 0.5, 10, 0.5);

	public boolean ignoreUpdate = false;
	public static boolean publicFreeze = false;
	public int waitTicks = 0, delayTicks = 0;
	private EntityPlayer target = null;

	public TickBase() {
		this.registerSetting(cooldown, range, freeze, timer);
	}

	@Override
	public void onEnable() {
		clear();
	}

	@Override
	public void onDisable() {
		clear();
	}
	
	@EventLink
	public void onTick(TickEvent e) {
		if (mc.player == null || mc.world == null) return;
		
		AimAssist c = (AimAssist) Haru.instance.getModuleManager().getModule(AimAssist.class);

		publicFreeze = false;

		if (waitTicks == 0) {
			waitTicks--;
			ignoreUpdate = true;
			for (int i = 0; i < freeze.getInputToInt() * timer.getInputToInt(); i++) {
				mc.world.updateEntities();
			}
			ignoreUpdate = false;
		}

		if (waitTicks > 0) {
			waitTicks--;
			publicFreeze = true;
		} else {
			
		}
		
		if (delayTicks > 0) {
			delayTicks--;
		}
		
		if (c.getEnemy() != null) {
			double entityDistance = mc.player.getDistanceToEntity(c.getEnemy());
			if (entityDistance <= range.getInputToInt() && entityDistance > 3 && mc.gameSettings.keyBindForward.pressed) {
				if (delayTicks > 0) {
				} else {
					waitTicks = freeze.getInputToInt() * 2;
					delayTicks = cooldown.getInputToInt() * 20;
				}
			}

		} else {
			clear();
			return;
		}

	}

	private void clear() {
		publicFreeze = false;
		ignoreUpdate = false;
	}

}
