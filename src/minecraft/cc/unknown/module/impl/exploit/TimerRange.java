package cc.unknown.module.impl.exploit;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.player.MoveUtil;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketUseEntity;
import net.minecraft.network.play.server.SPacketEntityVelocity;
import net.minecraft.util.MathHelper;

@Info(name = "TimerRange", category = Category.Exploit)
public class TimerRange extends Module {

	private SliderValue enemyRange = new SliderValue("Enemy Range", 3.5f, 1f, 5f, 0.05);
	private SliderValue positiveTimer = new SliderValue("Positive Timer", 1.5f, 0.01f, 35f, 0.01);
	private SliderValue positiveTicks = new SliderValue("Positive Ticks", 10, 1, 20, 1);
	
	private SliderValue negativeTimer = new SliderValue("Negative Timer", 0.45f, 0.05f, 5f, 0.05);
	private SliderValue negativeTick = new SliderValue("Negative Ticks", 10, 1, 50, 1);
	
	private int playerTicks = 0;
	private int cooldownTick = 0;
	private boolean confirmAttack = false;
	private boolean confirmKnockback = false;

	public TimerRange() {
		this.registerSetting(enemyRange, positiveTimer, positiveTicks, negativeTimer, negativeTick);
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		this.setSuffix("- [" + positiveTimer.getInput() + ", " + negativeTimer.getInput() + "]");
	}

	@Override
	public void onEnable() {
		timerReset();
	}

	@Override
	public void onDisable() {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onWorld(ChangeWorldEvent e) {
		timerReset();
		cooldownTick = 0;
		playerTicks = 0;
		confirmAttack = false;
		confirmKnockback = false;
	}

	@EventLink
	public void onLiving(LivingEvent e) {		
		double timerboost = MathHelper.randomValue(0.5, 0.5);
		double charged = MathHelper.randomValue(0.9, 0.9);

		if (playerTicks <= 0) {
			timerReset();
			return;
		}

		double tickProgress = playerTicks / positiveTicks.getInput();
		float playerSpeed;

		if (tickProgress < timerboost)
			playerSpeed = positiveTimer.getInputToFloat();
		else if (tickProgress < charged)
			playerSpeed = negativeTimer.getInputToFloat();
		else
			playerSpeed = 1f;

		float speedAdjustment = (float) (playerSpeed >= 0 ? playerSpeed : 1f + positiveTicks.getInput() - playerTicks);
		float adjustedTimerSpeed = Math.max(speedAdjustment, 0f);

		mc.timer.timerSpeed = adjustedTimerSpeed;

		playerTicks--;
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (e.isReceive()) {
			if (PlayerUtil.isMoving() && !shouldResetTimer()
					&& (mc.timer.timerSpeed > 1.0 || mc.timer.timerSpeed < 1.0)) {
				if (confirmKnockback) {
					if (p instanceof SPacketEntityVelocity) {
						SPacketEntityVelocity wrapper = (SPacketEntityVelocity) p;
						if (mc.player.getEntityId() == wrapper.getEntityID() && wrapper.getMotionY() > 0
								&& (wrapper.getMotionX() != 0.0 || wrapper.getMotionZ() != 0.0)) {
							confirmKnockback = false;
							timerReset();
						}
					}
				}
			}
		}

		if (e.isSend()) {
			if (p instanceof CPacketUseEntity) {
				CPacketUseEntity wrapper = (CPacketUseEntity) p;
				if (wrapper.getAction() != CPacketUseEntity.Mode.ATTACK && playerTicks >= 1) {
					timerReset();
					return;
				} else {
					confirmAttack = true;
				}

				double entityDistance = mc.player.getDistanceToEntity(wrapper.getEntityFromWorld(mc.world));

				cooldownTick++;

				boolean shouldSlowed = cooldownTick >= negativeTick.getInput() && entityDistance > enemyRange.getInput();

				if (shouldSlowed && confirmAttack) {
					confirmAttack = false;
					playerTicks = positiveTicks.getInputToInt();

					confirmKnockback = true;
					cooldownTick = 0;
				} else {
					timerReset();
				}
			}
		}
	}

	private boolean shouldResetTimer() {
		return (playerTicks >= 1 || mc.player.isSpectator() || mc.player.isDead || mc.player.isInWater()
				|| mc.player.isInLava() || mc.player.isInWeb || mc.player.isOnLadder() || mc.player.isRiding());
	}
	
	private double getDistancePrediction() {
		double predictX = mc.player.posX + ((mc.player.posX - mc.player.lastTickPosX) * 2);
		double predictZ = mc.player.posZ + ((mc.player.posZ - mc.player.lastTickPosZ) * 2);
		float f = (float) (predictX - mc.player.posX);
		float f1 = (float) (mc.player.posY - mc.player.posY);
		float f2 = (float) (predictZ - mc.player.posZ);
		double predictedDistance = MathHelper.sqrt_float(f * f + f1 * f1 + f2 * f2);
		return predictedDistance;
	}

	private void timerReset() {
		mc.timer.timerSpeed = 1f;
	}
}
