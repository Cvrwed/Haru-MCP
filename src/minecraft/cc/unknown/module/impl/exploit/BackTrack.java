package cc.unknown.module.impl.exploit;

import java.awt.Color;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.UpdateEvent;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.player.TickEvent;
import cc.unknown.event.impl.render.RenderEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.BooleanValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.ui.clickgui.impl.api.Theme;
import cc.unknown.utils.client.RenderUtil;
import cc.unknown.utils.network.TimedPacket;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketUseEntity;
import net.minecraft.network.play.server.SPacketChat;
import net.minecraft.network.play.server.SPacketClientDisconnect;
import net.minecraft.network.play.server.SPacketDestroyEntities;
import net.minecraft.network.play.server.SPacketEntity;
import net.minecraft.network.play.server.SPacketEntityStatus;
import net.minecraft.network.play.server.SPacketEntityTeleport;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.vec.Vec3;

@Register(name = "BackTrack", category = Category.Exploit)
public class BackTrack extends Module {

	private SliderValue latency = new SliderValue("Latency delay", 90, 1, 1000, 1);
	private SliderValue enemyDistance = new SliderValue("Enemy distance", 4.5, 3.1, 6.0, 0.01);
	private BooleanValue onlyCombat = new BooleanValue("Only during combat", true);
	private BooleanValue predictPosition = new BooleanValue("Render player position", true);
	private BooleanValue useThemeColor = new BooleanValue("Use themed colors", false);
	private SliderValue boxColor = new SliderValue("Box color [H/S/B]", 0, 0, 350, 10);
	private BooleanValue disableOnWorldChange = new BooleanValue("Disable on world change", false);
	private BooleanValue disableOnDisconnect = new BooleanValue("Disable on disconnect", false);
	private BooleanValue disableHurt = new BooleanValue("Disable when receive dmg", false);

	private Queue<TimedPacket> packetQueue = new ConcurrentLinkedQueue<>();
	private Vec3 vec3, lastVec3;
	private EntityPlayer target;
	private int attackTicks;

	public BackTrack() {
		this.registerSetting(latency, enemyDistance, onlyCombat, predictPosition, useThemeColor, boxColor,
				disableOnWorldChange, disableOnDisconnect, disableHurt);
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		this.setSuffix("- [" + latency.getInputToInt() + " ms]");
	}

	@Override
	public void onEnable() {
		super.onEnable();
		if (mc.player == null) {
			toggle();
			return;
		}

		packetQueue.clear();
		vec3 = lastVec3 = null;
		target = null;
	}

	@Override
	public void onDisable() {
		super.onDisable();
		if (mc.player == null)
			return;

		if (mc.player != null && !packetQueue.isEmpty())
			packetQueue.forEach(timedPacket -> {
				mc.getNetHandler().receiveSilent(timedPacket.getPacket());
			});
		packetQueue.clear();

	}

	@EventLink
	public void onPreUpdate(UpdateEvent e) {
		if (!e.isPre()) return;
		try {
			attackTicks++;

			if (attackTicks > 7 || vec3.distanceTo(mc.player.getPositionVector()) > enemyDistance.getInput()) {
				target = null;
				vec3 = lastVec3 = null;
			}

			lastVec3 = vec3;
		} catch (NullPointerException ignored) {

		}

	}

	@EventLink
	public void onPreTick(TickEvent.Pre e) {
		while (!packetQueue.isEmpty()) {
			if (packetQueue.peek().getCold().getCum(latency.getInputToInt())) {
				Packet<?> packet = packetQueue.poll().getPacket();
				mc.getNetHandler().receiveSilent(packet);
			} else {
				break;
			}
		}

		if (packetQueue.isEmpty() && target != null) {
			vec3 = target.getPositionVector();
		}
	}

	@EventLink
	public void onRender(RenderEvent e) {
		if (e.is3D()) {
			if (target == null)
				return;

			if (predictPosition.isToggled()) {
				RenderUtil.drawBox(target, vec3, lastVec3, useThemeColor.isToggled() ? Theme.instance.getMainColor()
						: Color.getHSBColor((boxColor.getInputToFloat() % 360) / 360.0f, 1.0f, 1.0f));
			}
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (disableHurt.isToggled() && mc.player.getHealth() < mc.player.getMaxHealth()) {
			if (mc.player.hurtTime != 0) {
				releaseAll();
				return;
			}
		}

		try {
			if (e.isReceive()) {

				if (mc.player == null || mc.player.ticksExisted < 20) {
					packetQueue.clear();
					return;
				}

				if (target == null) {
					releaseAll();
					return;
				}

				if (e.isCancelled())
					return;

				if (p instanceof SPacketEntityStatus || p instanceof SPacketChat)
					return;

				if (p instanceof SPacketPlayerPosLook || p instanceof SPacketClientDisconnect) {
					releaseAll();
					target = null;
					vec3 = lastVec3 = null;
					return;

				} else if (p instanceof SPacketDestroyEntities) {
					SPacketDestroyEntities wrapper = (SPacketDestroyEntities) p;
					for (int id : wrapper.getEntityIDs()) {
						if (id == target.getEntityId()) {
							target = null;
							vec3 = lastVec3 = null;
							releaseAll();
							return;
						}
					}
				} else if (p instanceof SPacketEntity) {
					SPacketEntity wrapper = (SPacketEntity) p;
					if (wrapper.getEntityId() == target.getEntityId()) {
						vec3 = vec3.addVector(wrapper.func_149062_c() / 32.0D, wrapper.func_149061_d() / 32.0D,
								wrapper.func_149064_e() / 32.0D);
					}
				} else if (p instanceof SPacketEntityTeleport) {
					SPacketEntityTeleport wrapper = (SPacketEntityTeleport) p;
					if (wrapper.getEntityId() == target.getEntityId()) {
						vec3 = new Vec3(wrapper.getX() / 32.0D, wrapper.getY() / 32.0D, wrapper.getZ() / 32.0D);
					}
				}

				packetQueue.add(new TimedPacket(p));
				e.setCancelled(true);
			}
		} catch (NullPointerException ignorethisshit) {

		}

		if (e.isSend()) {
			if (p instanceof CPacketUseEntity) {
				CPacketUseEntity wrapper = (CPacketUseEntity) p;
				if (onlyCombat.isToggled() && wrapper.getAction() != CPacketUseEntity.Mode.ATTACK)
					return;
				try {
					attackTicks = 0;

					EntityPlayer entity = (EntityPlayer) wrapper.getEntityFromWorld(mc.world);

					if (target != null && wrapper.getEntityId() == target.getEntityId())
						return;

					target = entity;
					vec3 = lastVec3 = entity.getPositionVector();
				} catch (ClassCastException fuck) {
				}
			}
		}
	}

	@EventLink
	public void disableOnWorldChange(ChangeWorldEvent e) {
		if (disableOnWorldChange.isToggled()) {
			this.disable();
		}
	}

	@EventLink
	public void onDisconnect(DisconnectionEvent e) {
		if (e.isClient()) {
			if (disableOnDisconnect.isToggled()) {
				this.disable();
			}
		}
	}

	private void releaseAll() {
		if (!packetQueue.isEmpty()) {
			packetQueue.forEach(timedPacket -> {
				mc.getNetHandler().receiveSilent(timedPacket.getPacket());
			});
			packetQueue.clear();
		}
	}

}