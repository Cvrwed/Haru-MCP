package cc.unknown.module.impl.exploit;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicReference;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.network.TimedPacket;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.play.server.SPacketChat;
import net.minecraft.network.play.server.SPacketCloseWindow;
import net.minecraft.network.play.server.SPacketTimeUpdate;
import net.minecraft.network.play.server.SPacketWindowItems;

@Info(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private Queue<TimedPacket> outboundPackets = new ConcurrentLinkedQueue<>();
	private Queue<TimedPacket> inboundPackets = new ConcurrentLinkedQueue<>();
	
	private SliderValue outboundDelay = new SliderValue("Outbound Delay", 250, 0, 1000, 10);
	private SliderValue inboundDelay = new SliderValue("Inbound Delay", 142, 0, 1000, 10);
	
	public FakeLag() {
		this.registerSetting(outboundDelay, inboundDelay);
	}

	@Override
	public void onEnable() {
		clearPackets();
		super.onEnable();
	}

	@Override
	public void onDisable() {
		clearPackets();
		super.onDisable();
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		AtomicReference<String> suffixRef = new AtomicReference<>();
		suffixRef.set("- [" + inboundDelay.getInputToInt() + " | " + outboundDelay.getInputToInt() + " ms]");
		this.setSuffix(suffixRef.get());
	}

	@EventLink
	public void onTick(LivingEvent e) {
		if (!PlayerUtil.inGame()) {
			resetPackets();
			this.toggle();
		}
		
		while (!outboundPackets.isEmpty()) {
			if (outboundPackets.peek().getCold().getCum(outboundDelay.getInputToInt())) {
				mc.player.sendQueue.sendSilent(outboundPackets.poll().getPacket());
			} else {
				break;
			}
		}
		
		while (!inboundPackets.isEmpty()) {
			if (inboundPackets.peek().getCold().getCum(inboundDelay.getInputToInt())) {
				mc.player.sendQueue.receiveSilent(inboundPackets.poll().getPacket());
			} else {
				break;
			}
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (!PlayerUtil.inGame()) {
			resetPackets();
		}
		
		if (e.getPacket() instanceof SPacketChat || e.getPacket() instanceof SPacketTimeUpdate)
			return;
		
		if (e.getPacket() instanceof SPacketCloseWindow || e.getPacket() instanceof SPacketWindowItems)
			return;

		if (e.isSend()) {			
			outboundPackets.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);
		}

		if (e.isReceive()) {
			inboundPackets.add(new TimedPacket(e.getPacket()));
			e.setCancelled(true);
		}
	}

	@EventLink
	public void onChangeWorld(ChangeWorldEvent e) {
		if (e.getChangeWorld() == null)
			clearPackets();
	}

	private void clearPackets() {
		if (PlayerUtil.inGame()) {
			for (TimedPacket packet : outboundPackets) {
				mc.getNetHandler().sendQueue(packet.getPacket());
			}
			for (TimedPacket packet : inboundPackets) {
				mc.getNetHandler().receiveSilent(packet.getPacket());
			}			
		} else {
			resetPackets();
		}
	}

	private void resetPackets() {
		outboundPackets.clear();
		inboundPackets.clear();
	}
}