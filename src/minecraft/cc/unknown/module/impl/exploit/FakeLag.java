package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicReference;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.player.TickEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.ModeValue;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.client.Cold;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.SPacketChat;
import net.minecraft.network.play.server.SPacketTimeUpdate;

@Register(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private final ArrayList<Packet<?>> inboundPackets = new ArrayList<>();
	private final ArrayList<Packet<?>> outboundPackets = new ArrayList<>();

	private ModeValue mode = new ModeValue("Mode", "Normal", "Normal");
	private SliderValue inboundDelay = new SliderValue("Inbound Delay", 142, 0, 1000, 10);
	private SliderValue outboundDelay = new SliderValue("Outbound Delay", 250, 0, 1000, 10);

	private Cold timer = new Cold(0);

	public FakeLag() {
		this.registerSetting(mode, inboundDelay, outboundDelay);
	}

	@Override
	public void onEnable() {
		super.onEnable();
	}

	@Override
	public void onDisable() {
		clearPackets();
		super.onDisable();
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		AtomicReference<String> suffixRef = new AtomicReference<>();
		suffixRef.set("- [" + inboundDelay.getInputToInt() + " | " + outboundDelay.getInputToInt() + " ms]");
		this.setSuffix(suffixRef.get());
	}

	@EventLink
	public void onTick(TickEvent.Pre e) {
		if (mc.player == null) {
			resetPackets();
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		if (mc.player == null) {
			resetPackets();
		}

		if (e.getPacket() instanceof SPacketChat || e.getPacket() instanceof SPacketTimeUpdate)
			return;

		if (e.isSend()) {
			if (mode.is("Normal")) {
				while (!outboundPackets.isEmpty()) {
					if (timer.getMillis() + outboundDelay.getInput() <= System.currentTimeMillis()) {
						outboundPackets.add(e.getPacket());
						e.setCancelled(true);
					} else {
						outboundPackets.forEach(p -> mc.player.sendQueue.sendSilent(p));
						timer.reset();
					}
				}
			}
		}

		if (e.isReceive()) {
			if (mode.is("Normal")) {
				while (!inboundPackets.isEmpty()) {
					if (timer.getMillis() + inboundDelay.getInput() <= System.currentTimeMillis()) {
						inboundPackets.add(e.getPacket());
						e.setCancelled(true);
					} else {
						inboundPackets.forEach(p -> mc.player.sendQueue.receiveSilent(p));
						timer.reset();
					}
				}
			}
		}
	}

	@EventLink
	public void onChangeWorld(ChangeWorldEvent e) {
		clearPackets();
	}

	@EventLink
	public void onDisconnect(final DisconnectionEvent e) {
		if (e.isClient()) {
			clearPackets();
			this.toggle();
		}
	}

	private void clearPackets() {
		if (mc.player != null) {
			if (!outboundPackets.isEmpty()) {
				outboundPackets.forEach(p -> mc.player.sendQueue.sendSilent(p));
				outboundPackets.clear();
			}

			if (!inboundPackets.isEmpty()) {
				inboundPackets.forEach(p -> mc.player.sendQueue.receiveSilent(p));
				inboundPackets.clear();
			}
		} else {
			resetPackets();
		}
	}

	private void resetPackets() {
		outboundPackets.clear();
		inboundPackets.clear();
		timer.reset();
	}
}