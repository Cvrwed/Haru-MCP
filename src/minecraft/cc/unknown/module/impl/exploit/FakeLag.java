package cc.unknown.module.impl.exploit;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.move.LivingEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Info;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.network.TimedPacket;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.*;

@Info(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

    private final List<TimedPacket> outboundPackets = new ArrayList<>();
    private final List<TimedPacket> inboundPackets = new ArrayList<>();
    
    private final SliderValue outboundDelay = new SliderValue("Outbound Delay", 250, 0, 1000, 10);
    private final SliderValue inboundDelay = new SliderValue("Inbound Delay", 142, 0, 1000, 10);
    
    public FakeLag() {
        this.registerSetting(outboundDelay, inboundDelay);
    }

    @Override
    public void onEnable() {
        clearPackets();
        super.onEnable();
    }

    @Override
    public void onDisable() {
        clearPackets();
        super.onDisable();
    }

    @EventLink
    public void onGui(ClickGuiEvent e) {
        this.setSuffix("- [" + inboundDelay.getInputToInt() + " | " + outboundDelay.getInputToInt() + " ms]");
    }

    @EventLink
    public void onLiving(LivingEvent e) {
        if (!PlayerUtil.inGame()) {
            resetPackets();
        }

        processPackets(outboundPackets, outboundDelay.getInputToInt(), true);
        processPackets(inboundPackets, inboundDelay.getInputToInt(), false);
    }

    @EventLink
    public void onPacket(PacketEvent e) {
        if (!PlayerUtil.inGame()) {
            resetPackets();
        }
        
        if (isExemptPacket(e.getPacket())) {
            return;
        }

        synchronized (outboundPackets) {
            if (e.isSend()) {
                outboundPackets.add(new TimedPacket(e.getPacket()));
                e.setCancelled(true);
            }
        }

        synchronized (inboundPackets) {
            if (e.isReceive()) {
                inboundPackets.add(new TimedPacket(e.getPacket()));
                e.setCancelled(true);
            }
        }
    }

    @EventLink
    public void onChangeWorld(ChangeWorldEvent e) {
        if (e.getChangeWorld() == null) {
            clearPackets();
        }
    }
    
    private void processPackets(List<TimedPacket> packets, int delay, boolean isOutbound) {
        synchronized (packets) {
            Iterator<TimedPacket> iterator = packets.iterator();
            while (iterator.hasNext()) {
                TimedPacket packet = iterator.next();
                if (packet.getCold().getCum(delay)) {
                    if (isOutbound) {
                        mc.player.sendQueue.sendSilent(packet.getPacket());
                    } else {
                        mc.player.sendQueue.receiveSilent(packet.getPacket());
                    }
                    iterator.remove();
                } else {
                    break;
                }
            }
        }
    }
    
    private void clearPackets() {
        synchronized (outboundPackets) {
            for (TimedPacket packet : outboundPackets) {
                mc.getNetHandler().sendQueue(packet.getPacket());
            }
            outboundPackets.clear();
        }

        synchronized (inboundPackets) {
            for (TimedPacket packet : inboundPackets) {
                mc.getNetHandler().receiveSilent(packet.getPacket());
            }
            inboundPackets.clear();
        }
    }

    private void resetPackets() {
        synchronized (outboundPackets) {
            outboundPackets.clear();
        }

        synchronized (inboundPackets) {
            inboundPackets.clear();
        }
    }
    
    private boolean isExemptPacket(Packet<?> packet) {
        return packet instanceof SPacketTimeUpdate
            || packet instanceof SPacketKeepAlive
            || packet instanceof SPacketChat
            || packet instanceof SPacketEntityStatus;
    }
}