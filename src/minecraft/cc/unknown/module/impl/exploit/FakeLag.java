package cc.unknown.module.impl.exploit;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicReference;

import cc.unknown.event.impl.EventLink;
import cc.unknown.event.impl.network.DisconnectionEvent;
import cc.unknown.event.impl.network.PacketEvent;
import cc.unknown.event.impl.other.ClickGuiEvent;
import cc.unknown.event.impl.world.ChangeWorldEvent;
import cc.unknown.module.impl.Module;
import cc.unknown.module.impl.api.Category;
import cc.unknown.module.impl.api.Register;
import cc.unknown.module.setting.impl.SliderValue;
import cc.unknown.utils.network.TimedPacket;
import cc.unknown.utils.player.PlayerUtil;
import net.minecraft.network.Packet;
import net.minecraft.network.handshake.client.CHandshake;
import net.minecraft.network.play.client.CPacketChatMessage;
import net.minecraft.network.play.client.CPacketClickWindow;
import net.minecraft.network.play.client.CPacketCloseWindow;
import net.minecraft.network.play.client.CPacketPlayerBlockPlacement;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketUpdateSign;
import net.minecraft.network.play.server.SPacketChat;
import net.minecraft.network.play.server.SPacketOpenWindow;
import net.minecraft.network.status.client.CPacketPing;
import net.minecraft.network.status.client.CPacketServerQuery;
import net.minecraft.network.status.server.SPacketPong;

@Register(name = "FakeLag", category = Category.Exploit)
public class FakeLag extends Module {

	private Queue<TimedPacket> inboundPackets = new ConcurrentLinkedQueue<>();
	private Queue<TimedPacket> outboundPackets = new ConcurrentLinkedQueue<>();

	private SliderValue inboundDelay = new SliderValue("Inbound Delay", 142, 0, 1000, 10);
	private SliderValue outboundDelay = new SliderValue("Outbound Delay", 250, 0, 1000, 10);
	private SliderValue chance = new SliderValue("Chance", 100, 0, 100, 1);

	public FakeLag() {
		this.registerSetting(inboundDelay, outboundDelay, chance);
	}

	@EventLink
	public void onGui(ClickGuiEvent e) {
		AtomicReference<String> suffixRef = new AtomicReference<>();
		suffixRef.set("- [" + inboundDelay.getInputToInt() + " | " + outboundDelay.getInputToInt() + " ms]");
		this.setSuffix(suffixRef.get());
	}

	@Override
	public void onEnable() {
		super.onEnable();
		if (mc.player == null) {
			toggle();
			return;
		}

		if ((mc.player != null && !inboundPackets.isEmpty()) || (mc.player != null && !outboundPackets.isEmpty())) {
			clearPackets();
		}
	}

	@Override
	public void onDisable() {
		super.onDisable();
		if (mc.player == null)
			return;

		if (mc.player != null && !inboundPackets.isEmpty()) {
			inboundPackets.forEach(p -> {
				mc.getNetHandler().receiveSilent(p.getPacket());
			});
			inboundPackets.clear();
		} else if (mc.player != null && !outboundPackets.isEmpty()) {
			outboundPackets.forEach(p -> {
				mc.getNetHandler().sendSilent(p.getPacket());
			});
			outboundPackets.clear();
		}
	}

	@EventLink
	public void onPacket(PacketEvent e) {
		Packet<?> p = e.getPacket();

		if (mc.player.isDead || !PlayerUtil.inGame() || mc.player.isInWater())
			return;

		if (p instanceof SPacketPong || p instanceof SPacketChat) {
			return;
		}

		if (p instanceof CPacketPlayerBlockPlacement || p instanceof CPacketPlayerDigging || p instanceof CPacketUpdateSign) {
			return;
		}

		if (p instanceof CPacketClickWindow || p instanceof CPacketCloseWindow || p instanceof SPacketOpenWindow) {
			return;
		}

		if (chance.getInput() != 100.0D) {
			if (Math.random() >= chance.getInput() / 100.0D) {
				return;
			}
		}

		if (e.isReceive()) {
			inboundPackets.add(new TimedPacket(p));
			e.setCancelled(true);

			while (!inboundPackets.isEmpty()) { // is better..
				if (inboundPackets.peek().getMillis() + inboundDelay.getInput() <= System.currentTimeMillis()) {
					mc.getNetHandler().receiveSilent(inboundPackets.poll().getPacket());
				} else {
					break;
				}
			}
		}

		if (e.isSend()) {
			outboundPackets.add(new TimedPacket(p));
			e.setCancelled(true);

			while (!outboundPackets.isEmpty()) {
				if (outboundPackets.peek().getMillis() + outboundDelay.getInput() <= System.currentTimeMillis()) {
					mc.getNetHandler().sendSilent(outboundPackets.poll().getPacket());
				} else {
					break;
				}
			}
		}
	}

	@EventLink
	public void onChangeWorld(ChangeWorldEvent e) {
		if (e.getChangeWorld() == null) {
			clearPackets();
		}
	}

	@EventLink
	public void onDisconnect(final DisconnectionEvent e) {
		if (e.isClient()) {
			clearPackets();
			this.disable();
		}
	}

	private void clearPackets() {
		this.outboundPackets.clear();
		this.inboundPackets.clear();
	}
}
